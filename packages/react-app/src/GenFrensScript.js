let tokenId = 1234;
let hash = "000000";
xo = 1, sd = 21 * tokenId, pCs = [0, 30, 80, 120, 180, 225, 270, 300], sCs = [0, 30, 120, 180, 225, 270, 300, 330], nMV = [.5, 1, 2, 3], eSs = [.26, .33, .4], tV = [10, 25, 70], eLs = [0, 15]; function setup() { createCanvas(500, 500), colorMode(HSB, 360, 100, 100), strokeCap(ROUND), noiseSeed(sd), randomSeed(sd), pC = parseInt(hash.substring(0, 1)), sC = parseInt(hash.substring(1, 2)), nM = parseInt(hash.substring(2, 3)), eS = parseInt(hash.substring(3, 4)), t = parseInt(hash.substring(4, 5)), eL = parseInt(hash.substring(5, 6)), 330 == sCs[sC] ? k = pCs[pC] : k = sCs[sC], wP = random(5, 10), hP = random(5, 10) } function draw() { background(255); for (let s = 25; s < 500; s += 50)for (let e = 25; e < 500; e += 50)noStroke(), f = sCs[sC], 330 == f ? rC = random(360) : rC = k, fill(rC, random(25), 100), c = new C1, push(), translate(s, e), scale(.14, .14), c.s(), pop(); c1 = new C2(pCs[pC], 40, 100, 0), push(), translate(250, 500), rotate(3.14), scale(.55, 1.25), c1.s(), pop(), push(), translate(250, 250), c1.s(), pop(), noStroke(), e1 = new C2(0, 0, 100, 1), push(), translate(200, 200), scale(.33), e1.s(), pop(), e2 = new C2(0, 0, 100, 1), push(), push(), translate(300, 200), scale(eSs[eS]), rotate(PI), e2.s(), pop(), p1 = new C2(k, 100, 100, 1), push(), translate(200, 200 + eLs[eL]), scale(.1), p1.s(), pop(), p2 = new C2(k, 100, 100, 1), push(), translate(300, 200 - eLs[eL]), scale(.1), rotate(PI), p2.s(), pop(); for (let s = 200; s <= 300; s++)sats = map(noise(xo), 0, 1, 30, 100), fill(k, sats, 95), r = map(noise(xo), 0, 1, .53, .77), ellipse(s, 500 * r, 28), xo += .015; noLoop() } class C1 { s() { beginShape(); for (let s = 0; s < TWO_PI; s += .16) { let e = map(cos(s), -1, 1, 0, nMV[nM]), t = map(sin(s), -1, 1, 0, nMV[nM]), n = map(noise(e, t), 0, 1, 100, 200), a = n * cos(s), p = n * sin(s); vertex(a, p), e += .004 } endShape() } } class C2 { constructor(s, e, t, n) { this.h = s, this.z = e, this.l = t, this.b = n } s() { beginShape(), noFill(); for (let s = 0; s < TWO_PI; s += .045) { let e = map(sin(s), -1, 1, 0, nMV[nM]), n = map(cos(s), -1, 1, 0, nMV[nM]), a = map(noise(n, e), 0, 1, 100, 200), p = a * cos(s), o = a * sin(s); 0 == this.b && (stroke(this.h, this.z, this.l - 25), strokeWeight(tV[t])), vertex(p, o), endShape(), push(), stroke(this.h, this.z, this.l), strokeWeight(6), line(p + 7.5, o + 10, 500 / wP, 500 / hP), pop(), n += .04, e += .001 } endShape() } }